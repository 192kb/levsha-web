/* eslint-disable @typescript-eslint/no-unused-vars */
// tslint:disable
/**
 * Проект LEVSHA
 * Levsha is open small work listing project
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: v.tyrin@icloud.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from './base';

/**
 *
 * @export
 * @interface ApiResponse
 */
export interface ApiResponse {
  /**
   *
   * @type {number}
   * @memberof ApiResponse
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof ApiResponse
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof ApiResponse
   */
  message?: string;
}
/**
 *
 * @export
 * @interface City
 */
export interface City {
  /**
   *
   * @type {number}
   * @memberof City
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof City
   */
  name: string;
  /**
   *
   * @type {boolean}
   * @memberof City
   */
  is_deleted: boolean;
}
/**
 *
 * @export
 * @interface District
 */
export interface District {
  /**
   *
   * @type {number}
   * @memberof District
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof District
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof District
   */
  city_id: number;
  /**
   *
   * @type {boolean}
   * @memberof District
   */
  is_deleted: boolean;
}
/**
 *
 * @export
 * @interface Message
 */
export interface Message {
  /**
   *
   * @type {number}
   * @memberof Message
   */
  id?: number;
  /**
   *
   * @type {number}
   * @memberof Message
   */
  user_from?: number;
  /**
   *
   * @type {number}
   * @memberof Message
   */
  user_to?: number;
  /**
   *
   * @type {number}
   * @memberof Message
   */
  task_id?: number;
  /**
   *
   * @type {string}
   * @memberof Message
   */
  message?: string;
  /**
   *
   * @type {string}
   * @memberof Message
   */
  date_created?: string;
  /**
   *
   * @type {string}
   * @memberof Message
   */
  date_read?: string;
  /**
   *
   * @type {boolean}
   * @memberof Message
   */
  is_deleted?: boolean;
}
/**
 *
 * @export
 * @interface Notification
 */
export interface Notification {
  /**
   *
   * @type {number}
   * @memberof Notification
   */
  id?: number;
  /**
   *
   * @type {number}
   * @memberof Notification
   */
  user_id?: number;
  /**
   *
   * @type {string}
   * @memberof Notification
   */
  title?: string;
  /**
   *
   * @type {string}
   * @memberof Notification
   */
  message?: string;
  /**
   *
   * @type {string}
   * @memberof Notification
   */
  date_created?: string;
  /**
   *
   * @type {string}
   * @memberof Notification
   */
  date_read?: string;
  /**
   *
   * @type {string}
   * @memberof Notification
   */
  payload?: string;
  /**
   *
   * @type {number}
   * @memberof Notification
   */
  notification_type_id?: number;
}
/**
 *
 * @export
 * @interface NotificationType
 */
export interface NotificationType {
  /**
   *
   * @type {number}
   * @memberof NotificationType
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof NotificationType
   */
  name?: string;
}
/**
 *
 * @export
 * @interface SignInParameters
 */
export interface SignInParameters {
  /**
   *
   * @type {string}
   * @memberof SignInParameters
   */
  phone: string;
  /**
   *
   * @type {string}
   * @memberof SignInParameters
   */
  password: string;
}
/**
 *
 * @export
 * @interface Task
 */
export interface Task {
  /**
   *
   * @type {string}
   * @memberof Task
   */
  uuid?: string;
  /**
   *
   * @type {User}
   * @memberof Task
   */
  user?: User;
  /**
   *
   * @type {string}
   * @memberof Task
   */
  date_created?: string;
  /**
   *
   * @type {boolean}
   * @memberof Task
   */
  is_active?: boolean;
  /**
   *
   * @type {string}
   * @memberof Task
   */
  title?: string;
  /**
   *
   * @type {string}
   * @memberof Task
   */
  description?: string;
  /**
   *
   * @type {number}
   * @memberof Task
   */
  price?: number;
  /**
   *
   * @type {string}
   * @memberof Task
   */
  unit?: string;
  /**
   *
   * @type {boolean}
   * @memberof Task
   */
  have_constant_price?: boolean;
  /**
   *
   * @type {string}
   * @memberof Task
   */
  date_start?: string;
  /**
   *
   * @type {string}
   * @memberof Task
   */
  date_finish?: string;
  /**
   *
   * @type {District}
   * @memberof Task
   */
  district?: District;
  /**
   *
   * @type {TaskCategory}
   * @memberof Task
   */
  category?: TaskCategory;
  /**
   *
   * @type {Array<TaskImages>}
   * @memberof Task
   */
  images?: Array<TaskImages>;
}
/**
 *
 * @export
 * @interface TaskCategory
 */
export interface TaskCategory {
  /**
   *
   * @type {number}
   * @memberof TaskCategory
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof TaskCategory
   */
  name?: string;
  /**
   *
   * @type {number}
   * @memberof TaskCategory
   */
  sorting?: number;
  /**
   *
   * @type {boolean}
   * @memberof TaskCategory
   */
  is_deprecated?: boolean;
}
/**
 *
 * @export
 * @interface TaskImages
 */
export interface TaskImages {
  /**
   *
   * @type {number}
   * @memberof TaskImages
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof TaskImages
   */
  date_created?: string;
  /**
   *
   * @type {string}
   * @memberof TaskImages
   */
  date_delete?: string;
  /**
   *
   * @type {boolean}
   * @memberof TaskImages
   */
  is_deleted?: boolean;
  /**
   *
   * @type {string}
   * @memberof TaskImages
   */
  url?: string;
  /**
   *
   * @type {number}
   * @memberof TaskImages
   */
  task_id?: number;
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {string}
   * @memberof User
   */
  uuid: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  firstname: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  secondname?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  lastname: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  date_created?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  last_change?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  date_deleted?: string;
  /**
   *
   * @type {boolean}
   * @memberof User
   */
  is_deleted?: boolean;
  /**
   *
   * @type {string}
   * @memberof User
   */
  login?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  password: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  phone: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  vk_profile?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  ok_profile?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  fb_profile?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  ig_profile?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  tw_profile?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  yt_profile?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  be_profile?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  li_profile?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  hh_profile?: string;
  /**
   *
   * @type {boolean}
   * @memberof User
   */
  phone_comfirmed?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof User
   */
  email_confirmed?: boolean;
  /**
   *
   * @type {string}
   * @memberof User
   */
  photo_url?: string;
  /**
   *
   * @type {City}
   * @memberof User
   */
  city?: City;
  /**
   *
   * @type {Array<User>}
   * @memberof User
   */
  starred_users?: Array<User>;
  /**
   *
   * @type {Array<User>}
   * @memberof User
   */
  hidden_users?: Array<User>;
}

/**
 * LocationApi - axios parameter creator
 * @export
 */
export const LocationApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Get list of current cities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCity: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/city`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookieAuth required

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get list of current cities
     * @param {number} cityId Id of queried city
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDiscrictsByCityId: async (
      cityId: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'cityId' is not null or undefined
      if (cityId === null || cityId === undefined) {
        throw new RequiredError(
          'cityId',
          'Required parameter cityId was null or undefined when calling getDiscrictsByCityId.'
        );
      }
      const localVarPath = `/city/{city_id}/district`.replace(
        `{${'city_id'}}`,
        encodeURIComponent(String(cityId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookieAuth required

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LocationApi - functional programming interface
 * @export
 */
export const LocationApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get list of current cities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCity(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<City>>
    > {
      const localVarAxiosArgs = await LocationApiAxiosParamCreator(
        configuration
      ).getCity(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Get list of current cities
     * @param {number} cityId Id of queried city
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDiscrictsByCityId(
      cityId: number,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<District>>
    > {
      const localVarAxiosArgs = await LocationApiAxiosParamCreator(
        configuration
      ).getDiscrictsByCityId(cityId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * LocationApi - factory interface
 * @export
 */
export const LocationApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary Get list of current cities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCity(options?: any): AxiosPromise<Array<City>> {
      return LocationApiFp(configuration)
        .getCity(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get list of current cities
     * @param {number} cityId Id of queried city
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDiscrictsByCityId(
      cityId: number,
      options?: any
    ): AxiosPromise<Array<District>> {
      return LocationApiFp(configuration)
        .getDiscrictsByCityId(cityId, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * LocationApi - object-oriented interface
 * @export
 * @class LocationApi
 * @extends {BaseAPI}
 */
export class LocationApi extends BaseAPI {
  /**
   *
   * @summary Get list of current cities
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LocationApi
   */
  public getCity(options?: any) {
    return LocationApiFp(this.configuration)
      .getCity(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get list of current cities
   * @param {number} cityId Id of queried city
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LocationApi
   */
  public getDiscrictsByCityId(cityId: number, options?: any) {
    return LocationApiFp(this.configuration)
      .getDiscrictsByCityId(cityId, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TaskApi - axios parameter creator
 * @export
 */
export const TaskApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Add a new task on board
     * @param {Task} task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTask: async (task: Task, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'task' is not null or undefined
      if (task === null || task === undefined) {
        throw new RequiredError(
          'task',
          'Required parameter task was null or undefined when calling addTask.'
        );
      }
      const localVarPath = `/task`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookieAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof task !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(task !== undefined ? task : {})
        : task || '';

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create new task category
     * @param {TaskCategory} taskCategory
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTaskCategory: async (
      taskCategory: TaskCategory,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskCategory' is not null or undefined
      if (taskCategory === null || taskCategory === undefined) {
        throw new RequiredError(
          'taskCategory',
          'Required parameter taskCategory was null or undefined when calling createTaskCategory.'
        );
      }
      const localVarPath = `/task/category`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookieAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof taskCategory !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(taskCategory !== undefined ? taskCategory : {})
        : taskCategory || '';

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get list of first tasks by location id
     * @summary Finds tasks by location
     * @param {number} locationId Id of queried location
     * @param {number} [page] Status values that need to be considered for filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findTasksByLocation: async (
      locationId: number,
      page?: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'locationId' is not null or undefined
      if (locationId === null || locationId === undefined) {
        throw new RequiredError(
          'locationId',
          'Required parameter locationId was null or undefined when calling findTasksByLocation.'
        );
      }
      const localVarPath = `/task/by_location/{location_id}`.replace(
        `{${'location_id'}}`,
        encodeURIComponent(String(locationId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookieAuth required

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get an existing task detailed
     * @param {string} taskId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTask: async (
      taskId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskId' is not null or undefined
      if (taskId === null || taskId === undefined) {
        throw new RequiredError(
          'taskId',
          'Required parameter taskId was null or undefined when calling getTask.'
        );
      }
      const localVarPath = `/task/item/{task_id}`.replace(
        `{${'task_id'}}`,
        encodeURIComponent(String(taskId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookieAuth required

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get list of task categories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaskCategories: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/task/category`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookieAuth required

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get list of tasks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTasks: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/task`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookieAuth required

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Removes given task category
     * @param {number} taskCategoryId Id of queried location
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeTaskCategory: async (
      taskCategoryId: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskCategoryId' is not null or undefined
      if (taskCategoryId === null || taskCategoryId === undefined) {
        throw new RequiredError(
          'taskCategoryId',
          'Required parameter taskCategoryId was null or undefined when calling removeTaskCategory.'
        );
      }
      const localVarPath = `/task/category/{task_category_id}`.replace(
        `{${'task_category_id'}}`,
        encodeURIComponent(String(taskCategoryId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookieAuth required

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update an existing task
     * @param {string} taskId
     * @param {Task} task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTask: async (
      taskId: string,
      task: Task,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskId' is not null or undefined
      if (taskId === null || taskId === undefined) {
        throw new RequiredError(
          'taskId',
          'Required parameter taskId was null or undefined when calling updateTask.'
        );
      }
      // verify required parameter 'task' is not null or undefined
      if (task === null || task === undefined) {
        throw new RequiredError(
          'task',
          'Required parameter task was null or undefined when calling updateTask.'
        );
      }
      const localVarPath = `/task/item/{task_id}`.replace(
        `{${'task_id'}}`,
        encodeURIComponent(String(taskId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookieAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof task !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(task !== undefined ? task : {})
        : task || '';

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update given task category
     * @param {number} taskCategoryId Id of queried location
     * @param {TaskCategory} taskCategory
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTaskCategory: async (
      taskCategoryId: number,
      taskCategory: TaskCategory,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskCategoryId' is not null or undefined
      if (taskCategoryId === null || taskCategoryId === undefined) {
        throw new RequiredError(
          'taskCategoryId',
          'Required parameter taskCategoryId was null or undefined when calling updateTaskCategory.'
        );
      }
      // verify required parameter 'taskCategory' is not null or undefined
      if (taskCategory === null || taskCategory === undefined) {
        throw new RequiredError(
          'taskCategory',
          'Required parameter taskCategory was null or undefined when calling updateTaskCategory.'
        );
      }
      const localVarPath = `/task/category/{task_category_id}`.replace(
        `{${'task_category_id'}}`,
        encodeURIComponent(String(taskCategoryId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookieAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof taskCategory !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(taskCategory !== undefined ? taskCategory : {})
        : taskCategory || '';

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TaskApi - functional programming interface
 * @export
 */
export const TaskApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Add a new task on board
     * @param {Task} task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addTask(
      task: Task,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>
    > {
      const localVarAxiosArgs = await TaskApiAxiosParamCreator(
        configuration
      ).addTask(task, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Create new task category
     * @param {TaskCategory} taskCategory
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createTaskCategory(
      taskCategory: TaskCategory,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await TaskApiAxiosParamCreator(
        configuration
      ).createTaskCategory(taskCategory, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get list of first tasks by location id
     * @summary Finds tasks by location
     * @param {number} locationId Id of queried location
     * @param {number} [page] Status values that need to be considered for filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findTasksByLocation(
      locationId: number,
      page?: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>
    > {
      const localVarAxiosArgs = await TaskApiAxiosParamCreator(
        configuration
      ).findTasksByLocation(locationId, page, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Get an existing task detailed
     * @param {string} taskId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTask(
      taskId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>
    > {
      const localVarAxiosArgs = await TaskApiAxiosParamCreator(
        configuration
      ).getTask(taskId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Get list of task categories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTaskCategories(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<TaskCategory>>
    > {
      const localVarAxiosArgs = await TaskApiAxiosParamCreator(
        configuration
      ).getTaskCategories(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Get list of tasks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTasks(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>
    > {
      const localVarAxiosArgs = await TaskApiAxiosParamCreator(
        configuration
      ).getTasks(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Removes given task category
     * @param {number} taskCategoryId Id of queried location
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeTaskCategory(
      taskCategoryId: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await TaskApiAxiosParamCreator(
        configuration
      ).removeTaskCategory(taskCategoryId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Update an existing task
     * @param {string} taskId
     * @param {Task} task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateTask(
      taskId: string,
      task: Task,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>
    > {
      const localVarAxiosArgs = await TaskApiAxiosParamCreator(
        configuration
      ).updateTask(taskId, task, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Update given task category
     * @param {number} taskCategoryId Id of queried location
     * @param {TaskCategory} taskCategory
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateTaskCategory(
      taskCategoryId: number,
      taskCategory: TaskCategory,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await TaskApiAxiosParamCreator(
        configuration
      ).updateTaskCategory(taskCategoryId, taskCategory, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * TaskApi - factory interface
 * @export
 */
export const TaskApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary Add a new task on board
     * @param {Task} task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTask(task: Task, options?: any): AxiosPromise<Task> {
      return TaskApiFp(configuration)
        .addTask(task, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create new task category
     * @param {TaskCategory} taskCategory
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTaskCategory(
      taskCategory: TaskCategory,
      options?: any
    ): AxiosPromise<void> {
      return TaskApiFp(configuration)
        .createTaskCategory(taskCategory, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get list of first tasks by location id
     * @summary Finds tasks by location
     * @param {number} locationId Id of queried location
     * @param {number} [page] Status values that need to be considered for filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findTasksByLocation(
      locationId: number,
      page?: number,
      options?: any
    ): AxiosPromise<Array<Task>> {
      return TaskApiFp(configuration)
        .findTasksByLocation(locationId, page, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get an existing task detailed
     * @param {string} taskId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTask(taskId: string, options?: any): AxiosPromise<Task> {
      return TaskApiFp(configuration)
        .getTask(taskId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get list of task categories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaskCategories(options?: any): AxiosPromise<Array<TaskCategory>> {
      return TaskApiFp(configuration)
        .getTaskCategories(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get list of tasks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTasks(options?: any): AxiosPromise<Array<Task>> {
      return TaskApiFp(configuration)
        .getTasks(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Removes given task category
     * @param {number} taskCategoryId Id of queried location
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeTaskCategory(
      taskCategoryId: number,
      options?: any
    ): AxiosPromise<void> {
      return TaskApiFp(configuration)
        .removeTaskCategory(taskCategoryId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update an existing task
     * @param {string} taskId
     * @param {Task} task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTask(taskId: string, task: Task, options?: any): AxiosPromise<Task> {
      return TaskApiFp(configuration)
        .updateTask(taskId, task, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update given task category
     * @param {number} taskCategoryId Id of queried location
     * @param {TaskCategory} taskCategory
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTaskCategory(
      taskCategoryId: number,
      taskCategory: TaskCategory,
      options?: any
    ): AxiosPromise<void> {
      return TaskApiFp(configuration)
        .updateTaskCategory(taskCategoryId, taskCategory, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * TaskApi - object-oriented interface
 * @export
 * @class TaskApi
 * @extends {BaseAPI}
 */
export class TaskApi extends BaseAPI {
  /**
   *
   * @summary Add a new task on board
   * @param {Task} task
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskApi
   */
  public addTask(task: Task, options?: any) {
    return TaskApiFp(this.configuration)
      .addTask(task, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create new task category
   * @param {TaskCategory} taskCategory
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskApi
   */
  public createTaskCategory(taskCategory: TaskCategory, options?: any) {
    return TaskApiFp(this.configuration)
      .createTaskCategory(taskCategory, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get list of first tasks by location id
   * @summary Finds tasks by location
   * @param {number} locationId Id of queried location
   * @param {number} [page] Status values that need to be considered for filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskApi
   */
  public findTasksByLocation(locationId: number, page?: number, options?: any) {
    return TaskApiFp(this.configuration)
      .findTasksByLocation(locationId, page, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get an existing task detailed
   * @param {string} taskId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskApi
   */
  public getTask(taskId: string, options?: any) {
    return TaskApiFp(this.configuration)
      .getTask(taskId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get list of task categories
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskApi
   */
  public getTaskCategories(options?: any) {
    return TaskApiFp(this.configuration)
      .getTaskCategories(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get list of tasks
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskApi
   */
  public getTasks(options?: any) {
    return TaskApiFp(this.configuration)
      .getTasks(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Removes given task category
   * @param {number} taskCategoryId Id of queried location
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskApi
   */
  public removeTaskCategory(taskCategoryId: number, options?: any) {
    return TaskApiFp(this.configuration)
      .removeTaskCategory(taskCategoryId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update an existing task
   * @param {string} taskId
   * @param {Task} task
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskApi
   */
  public updateTask(taskId: string, task: Task, options?: any) {
    return TaskApiFp(this.configuration)
      .updateTask(taskId, task, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update given task category
   * @param {number} taskCategoryId Id of queried location
   * @param {TaskCategory} taskCategory
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskApi
   */
  public updateTaskCategory(
    taskCategoryId: number,
    taskCategory: TaskCategory,
    options?: any
  ) {
    return TaskApiFp(this.configuration)
      .updateTaskCategory(taskCategoryId, taskCategory, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Registration of new user
     * @summary Create user
     * @param {User} user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser: async (user: User, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'user' is not null or undefined
      if (user === null || user === undefined) {
        throw new RequiredError(
          'user',
          'Required parameter user was null or undefined when calling createUser.'
        );
      }
      const localVarPath = `/user`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookieAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof user !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(user !== undefined ? user : {})
        : user || '';

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This can only be done by the logged in user with privilegy.
     * @summary Delete user
     * @param {string} username The name that needs to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser: async (
      username: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      if (username === null || username === undefined) {
        throw new RequiredError(
          'username',
          'Required parameter username was null or undefined when calling deleteUser.'
        );
      }
      const localVarPath = `/user/{username}`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookieAuth required

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get current user from session, eg after reload of app
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUser: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/user`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookieAuth required

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get user by user name
     * @param {string} username The name that needs to be fetched. Use user1 for testing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserByName: async (
      username: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      if (username === null || username === undefined) {
        throw new RequiredError(
          'username',
          'Required parameter username was null or undefined when calling getUserByName.'
        );
      }
      const localVarPath = `/user/{username}`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookieAuth required

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Logs user into the system
     * @param {SignInParameters} signInParameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginUser: async (
      signInParameters: SignInParameters,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'signInParameters' is not null or undefined
      if (signInParameters === null || signInParameters === undefined) {
        throw new RequiredError(
          'signInParameters',
          'Required parameter signInParameters was null or undefined when calling loginUser.'
        );
      }
      const localVarPath = `/user/login`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookieAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof signInParameters !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(signInParameters !== undefined ? signInParameters : {})
        : signInParameters || '';

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Logs out current logged in user session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logoutUser: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/user/logout`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookieAuth required

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This can only be done by the logged in user.
     * @summary Updated user
     * @param {string} username name that need to be updated
     * @param {User} user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser: async (
      username: string,
      user: User,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      if (username === null || username === undefined) {
        throw new RequiredError(
          'username',
          'Required parameter username was null or undefined when calling updateUser.'
        );
      }
      // verify required parameter 'user' is not null or undefined
      if (user === null || user === undefined) {
        throw new RequiredError(
          'user',
          'Required parameter user was null or undefined when calling updateUser.'
        );
      }
      const localVarPath = `/user/{username}`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookieAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof user !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(user !== undefined ? user : {})
        : user || '';

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Registration of new user
     * @summary Create user
     * @param {User} user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createUser(
      user: User,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await UserApiAxiosParamCreator(
        configuration
      ).createUser(user, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This can only be done by the logged in user with privilegy.
     * @summary Delete user
     * @param {string} username The name that needs to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUser(
      username: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await UserApiAxiosParamCreator(
        configuration
      ).deleteUser(username, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Get current user from session, eg after reload of app
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCurrentUser(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await UserApiAxiosParamCreator(
        configuration
      ).getCurrentUser(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Get user by user name
     * @param {string} username The name that needs to be fetched. Use user1 for testing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserByName(
      username: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await UserApiAxiosParamCreator(
        configuration
      ).getUserByName(username, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Logs user into the system
     * @param {SignInParameters} signInParameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async loginUser(
      signInParameters: SignInParameters,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await UserApiAxiosParamCreator(
        configuration
      ).loginUser(signInParameters, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Logs out current logged in user session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async logoutUser(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>
    > {
      const localVarAxiosArgs = await UserApiAxiosParamCreator(
        configuration
      ).logoutUser(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This can only be done by the logged in user.
     * @summary Updated user
     * @param {string} username name that need to be updated
     * @param {User} user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateUser(
      username: string,
      user: User,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await UserApiAxiosParamCreator(
        configuration
      ).updateUser(username, user, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     * Registration of new user
     * @summary Create user
     * @param {User} user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(user: User, options?: any): AxiosPromise<User> {
      return UserApiFp(configuration)
        .createUser(user, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * This can only be done by the logged in user with privilegy.
     * @summary Delete user
     * @param {string} username The name that needs to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(username: string, options?: any): AxiosPromise<void> {
      return UserApiFp(configuration)
        .deleteUser(username, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get current user from session, eg after reload of app
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUser(options?: any): AxiosPromise<User> {
      return UserApiFp(configuration)
        .getCurrentUser(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get user by user name
     * @param {string} username The name that needs to be fetched. Use user1 for testing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserByName(username: string, options?: any): AxiosPromise<User> {
      return UserApiFp(configuration)
        .getUserByName(username, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Logs user into the system
     * @param {SignInParameters} signInParameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginUser(
      signInParameters: SignInParameters,
      options?: any
    ): AxiosPromise<User> {
      return UserApiFp(configuration)
        .loginUser(signInParameters, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Logs out current logged in user session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logoutUser(options?: any): AxiosPromise<ApiResponse> {
      return UserApiFp(configuration)
        .logoutUser(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * This can only be done by the logged in user.
     * @summary Updated user
     * @param {string} username name that need to be updated
     * @param {User} user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser(
      username: string,
      user: User,
      options?: any
    ): AxiosPromise<void> {
      return UserApiFp(configuration)
        .updateUser(username, user, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
  /**
   * Registration of new user
   * @summary Create user
   * @param {User} user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public createUser(user: User, options?: any) {
    return UserApiFp(this.configuration)
      .createUser(user, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This can only be done by the logged in user with privilegy.
   * @summary Delete user
   * @param {string} username The name that needs to be deleted
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public deleteUser(username: string, options?: any) {
    return UserApiFp(this.configuration)
      .deleteUser(username, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get current user from session, eg after reload of app
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public getCurrentUser(options?: any) {
    return UserApiFp(this.configuration)
      .getCurrentUser(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get user by user name
   * @param {string} username The name that needs to be fetched. Use user1 for testing.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public getUserByName(username: string, options?: any) {
    return UserApiFp(this.configuration)
      .getUserByName(username, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Logs user into the system
   * @param {SignInParameters} signInParameters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public loginUser(signInParameters: SignInParameters, options?: any) {
    return UserApiFp(this.configuration)
      .loginUser(signInParameters, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Logs out current logged in user session
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public logoutUser(options?: any) {
    return UserApiFp(this.configuration)
      .logoutUser(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This can only be done by the logged in user.
   * @summary Updated user
   * @param {string} username name that need to be updated
   * @param {User} user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public updateUser(username: string, user: User, options?: any) {
    return UserApiFp(this.configuration)
      .updateUser(username, user, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
